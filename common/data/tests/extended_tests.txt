# Extended test suite for FSA Engine
# Tests various regex patterns and edge cases

# ===== Basic Patterns =====

[Basic_EndsWith1]
regex = (0|1)*1
input = 0101

[Basic_EndsWith0]
regex = (0|1)*0
input = 0100

[Basic_EndsWithTwo1s]
regex = (0|1)*11
input = 01011

[Basic_EndsWithTwo0s]
regex = (0|1)*00
input = 01100

# ===== Simple Literals =====

[Literal_ExactMatch]
regex = 0101
input = 0101

[Literal_NoMatch]
regex = 0101
input = 0100

[Literal_PartialMatch]
regex = 0101
input = 01010

# ===== Kleene Star Tests =====

[Star_EmptyString]
regex = (0|1)*
input = 

[Star_RepeatedBits]
regex = 1*0*
input = 11110000

[Star_MixedOrder]
regex = 1*0*
input = 11001100

# ===== Alternation Tests =====

[Alt_SingleChar]
regex = 0|1
input = 0

[Alt_NestedGroups]
regex = (00|11)(01|10)
input = 0010

[Alt_Mixed]
regex = (00|11)(01|10)
input = 1101

[Alt_Invalid]
regex = (00|11)(01|10)
input = 0000

# ===== Length-Based Patterns =====

[Length_Even]
# Even length strings
regex = (01|10|00|11)(01|10|00|11)*
input = 0101

[Length_Odd]
# Odd length strings (impossible with paired bits)
regex = (01|10|00|11)(01|10|00|11)*
input = 010

[Length_Mod3]
# Length is multiple of 3
regex = ((0|1)(0|1)(0|1))*
input = 010101

[Length_NotMod3]
regex = ((0|1)(0|1)(0|1))*
input = 0101

# ===== Position-Based Patterns =====

[Position_StartsWith1]
regex = 1(0|1)*
input = 1010

[Position_StartsWith0]
regex = 0(0|1)*
input = 0010

[Position_StartsAndEnds]
regex = 1(0|1)*1
input = 1001

# ===== Pattern Combinations =====

[Combo_StartEnd]
regex = 1(0|1)*0
input = 10110

[Combo_NoMiddle0]
regex = 1[^0]*1
input = 1111

[Combo_ThreeConsecutive1s]
regex = (0|1)*111(0|1)*
input = 0111010

[Combo_No3Consecutive1s]
regex = (0|(10)|(110))*
input = 01101010

# ===== Edge Cases =====

[Edge_SingleChar]
regex = 0
input = 0

[Edge_EmptyString]
regex = 
input = 

[Edge_LongString]
regex = (0|1)*
input = 0101010101010101010101010101010101010101

[Edge_ZeroOnes]
regex = 0*1*
input = 000111

# ===== Special Patterns =====

[Special_ContainsSubstring]
# Contains '101'
regex = (0|1)*101(0|1)*
input = 0010100

[Special_NoContainsSubstring]
regex = (0|1)*101(0|1)*
input = 001100

[Special_DivisibleBy3]
# Number represented in binary is divisible by 3
# (Simplified: just check if binary ends with 00 or 11)
regex = (0|1)*(00|11)
input = 1100

[Special_AlternatingBits]
# Alternating 0s and 1s
regex = (01)*(0)?|(10)*(1)?
input = 010101

[Special_NotAlternating]
regex = (01)*(0)?|(10)*(1)?
input = 01100

# ===== NEW: Advanced Regex Features =====

[Adv_OptionalElement]
regex = 10?1
input = 101

[Adv_OptionalElement2]
regex = 10?1
input = 11

[Adv_OptionalElement3]
regex = 10?1
input = 100

[Adv_Repetition]
regex = 1{3}
input = 111

[Adv_RepetitionFail]
regex = 1{3}
input = 11

[Adv_RepetitionGroup]
regex = (01){2}
input = 0101

[Adv_NestedGroups]
regex = ((01){2}0)*
input = 01010

# ===== NEW: Negation Patterns =====

[Neg_NoZeros]
regex = 1*
input = 111

[Neg_NoZerosFail]
regex = 1*
input = 1101

[Neg_NegatedClass]
regex = 0[^0]*0
input = 01110

[Neg_DoubleNegation]
regex = 1[^0]*[^1]*0
input = 11110

# ===== NEW: Complex Combinations =====

[Complex_Even1s]
# Binary strings with even number of 1s
regex = (0*(10*10*))*
input = 00100100

[Complex_Even1sFail]
regex = (0*(10*10*))*
input = 0010010

[Complex_DivisibleBy4]
# Binary string representing number divisible by 4 (ends with 00)
regex = (0|1)*00
input = 10100

[Complex_MultOf3]
# Matches binary strings that are multiples of 3
regex = (0|(1(01*0)*1))*
input = 110

[Complex_NotMultOf3]
regex = (0|(1(01*0)*1))*
input = 10

[Complex_Palindrome4]
# Binary palindromes of length 4
regex = (00|11)(00|11)|(01|10)(10|01)
input = 1001

[Complex_Palindrome4Fail]
regex = (00|11)(00|11)|(01|10)(10|01)
input = 1010

[Complex_NoConsecutive1]
# No consecutive 1s
regex = (0|10)*1?
input = 010101

[Complex_NoConsecutive1Fail]
regex = (0|10)*1?
input = 0110
